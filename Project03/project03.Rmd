---
title: "Project 03"
author: "Zoe Chow, Jacqueline Caldwell"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
reticulate::use_condaenv(condaenv = "r-reticulate")
```

---

# Gibbs sampling

---
## Imports

For this project, it tasks you with creating a sequence logo to plot the motif sequences identified through your algorithm.
This is a very minor portion of the project and is best used for checking your work. That means that if you cannot get the library
that you are about to install to work, don't worry. At a bare minimum, you only need `numpy` to complete this project.

```{r, install_seqlogo}
reticulate::conda_install(
  envname = "r-reticulate", 
  packages=c("seqlogo", "pdf2svg", "setuptools"),
  channel=c("bioconda", "conda-forge"), 
  conda="auto", 
  additionall_install_args="--solver=libmamba"
)
```


```{python LoadPackages}
import numpy as np
import random
import math
import seqlogo

#import function for building sequence motif & idenfitying seqs matching to motif
from data_readers import *
from seq_ops import get_seq
from motif_ops import *
```

---
## Implement Gibbs Sampler


Gibbs sampling is a MCMC approach to identify enrichments. Here we will implement a method to identify motifs from a set of regions. 

Important considerations:
- We will need to score each sequence with a PWM using the `score_kmer()` or `score_sequence()` functions
    - You will need to investigate into the help documenation and libraries to identify how best to use these functions. 
- These sites are often not strand-specific and so both scores on the negative as well as positive strand should be considered
- To select a random sequence, use `random.randint()` or `numpy.random.randint()`
- To select a new position $m$ (as defined below) use `random.choices()` or `numpy.random.choice()`  

Assumptions: 
- We know $k$ as the length of expected motif
- Each sequence contains the motif


Probability of chosing position $m$ = \frac{A_{m}}{\sum_{l}A_{l}}$ for positions $l$ in DNAi


**Note:** I have also added a function to `motif_ops.py` that will calculate the information content of your motifs. This is useful to observe the progression of your Gibbs sampler as well as a measure of convergence. You can use this function as `IC = pfm_ic(pfm)`. You should expect a slow increase of IC until it plateaus such as in the plot below from your lecture slides:   ![]('figures/Gibbs_Sampling.png')


```
GibbsMotifFinder(DNA, k-length)
    random pick of k-length sequences from each line of DNA as Motifs
    for j ← 1 to 10000 or Motifs stops changing
        i ← Random(N) where N is number of DNA entries
        PWM ← PWM constructed from all Motifs except for Motifi
        Motifi ← select position m from PWM-scored k-mers in DNAi in probabilistic fashion from score distribution
    return PFM
```

```{python fuzzy_diff}
#Support functions for GibbsMotifFinder()

def fuzzy_diff(x, y, epsilon):
    """
    Compares x and y within epsilon difference, and returns true or false
  
    Args:
      x,y (floats):  values to be compared, are they within epislon of each other if so function returns TRUE, otherwise, returns FALSE
    epsilon (float) - the amount of difference, or tolerance between X & Y that we will allow
    
    Returns (boolean): if abs(x-y) os greater than epislon
    """
    
    if (abs(x-y) < epsilon):
      return(1) # basically the same!
    else:
      return(0) # not the same!
```


```{python create_possible_motif}
def create_possible_motif(sequence, k=10):
    """
    Create a k-length motif from a larger sequence, using random selection
      
    Args:
      sequence (string):   single sequence to find a random motif in
      k (int):        length of proposed motif
        
    Returns:
      string of length k: containing motif 
    """
          
          
    N = random.randint(0, len(sequence)-k)
    return (sequence[N:N+10])

```

```{python MaxGibbsMotifFinder}
def GibbsMotifFinder1 (seqs, k, seed=42):
    """
    Function to find a pfm from a list of strings using a Gibbs sampler
  
    Args: 
      seqs (str list): a list of sequences, not necessarily in same lengths
      k (int): the length of motif to find
      seed (int, default=42): seed for np.random
    
    Returns:
      pfm (numpy array): dimensions are 4xlength
      
    """
    len_seq = len(seqs)
    background = []  # will be length(seq)-1
    poss_motif = []  # k-length of each seq
    pfm = []
    old_ic = 0
      
    for seq in seqs:
      poss_motif.append(create_possible_motif(seq,k))
    
        
    j = counter_ic = 0  # Set counter for j and IC
    
    while ((j < 1000) or (counter_ic < 10)): # REMEMBER to fix the if statement below 

      N = random.randint(0, len_seq-1) #works without giving an array

      new_seq = seqs[N]
      background = seqs[:N] + seqs[N+1:]
      bgPWM = build_pwm(build_pfm(background,k))
        
      list_of_motifs=[]
      scores_of_motifs=[]
        
      # Create the second for loop within 
      for i in range(len(new_seq)-k):  
        # sliding window of k-mer bp over our 50bp
        k_motif = new_seq[i:i+k]
        list_of_motifs.append(k_motif)
        new_kmer = score_kmer(k_motif, bgPWM)
        scores_of_motifs.append(new_kmer)  
            
      best_index = scores_of_motifs.index(max(scores_of_motifs))  
            
      motif = list(list_of_motifs[best_index])
            
      pfm = build_pfm(motif,k)
           
      new_ic = pfm_ic(pfm) 

            
      if (fuzzy_diff (new_ic,old_ic,0.000001)):
        old_ic = new_ic
        counter_ic = 0
      else:
        counter_ic+=1
                
      j+=1
     
      if ((counter_ic == 2) or (j==1000)):
        print("the returned PFM is for {motif}:",motif)
        return(np.array(pfm))
      
      #end of while loop
                
    print("before return:pfm",pfm)
    return (pfm)

#Testing code
promoter_pfm = GibbsMotifFinder(seqs,10)
```

```{python}
def choose_motif(motif_list, scores):
  '''
  function choose_motif takes a string of motif values and scores, and selects one in the list randomly, returning the index into the array given.  Scores should come from the calculations on the motif_list, so they need to be of the same length
  
  args:
    motif_list (list of strings): list of motifs 
    scores (list of floats):      list of information scores that are associated directly with the motifs in the prior array.
  '''
  if (motif_list):
    if len(motif_list) == len(scores):
      picked_item = random.choices(motif_list, weights=scores, k=1)[0]  
      return(motif_list.index(picked_item))
    else:
      print(f"Error: choose_motif(): {motif_list}, {current_ic} are not the same length")
  else:
    print("Error: No list of motifs found")
    return("")
```



```{python GibbsMotifFinderV2}
def GibbsMotifFinder (seqs, k, seed=42):
    """
    Function to find a pfm from a list of strings using a Gibbs sampler
  
    Args: 
      seqs (str list): a list of sequences, not necessarily in same lengths
      k (int): the length of motif to find
      seed (int, default=42): seed for np.random
    
    Returns:
      pfm (numpy array): dimensions are 4xlength
      
    """
    len_seq = len(seqs)
    background = []  # will be length(seq)-1
    poss_motif = poss_motif_score = []  # k-length of each possible motif
    pfm = []
    old_ic = 0
      
    for seq in seqs:
      poss_motif.append(create_possible_motif(seq,k))
      poss_motif_score.append(0) #initialize everyone to 0 
      ## poss_motif should be used for calculating the PWM --> I don't think a score is needed for each possible motif 
    
    j = counter_ic = 0  # Set counter for j and IC
    
    while ((j < 1000) and (counter_ic < 10)): 

      N = random.randint(0, len_seq-1)  # generate random number for selecting motif/sequence

      new_seq = seqs[N]  # store full length sequence to loop through and calculate k-scores and ICs
      
      ## background = poss_motif[:N] + poss_motif[N+1:]
      background = seqs[:N] + seqs[N+1:]  # set of seqs that doesn't include new_seq
      
      bgPWM = build_pwm(build_pfm(background,k)) # create background PWM
      
      # NOTE:  DNAi arrays are local arrays only, they need to be reset each time you go through the big loop
      for i in range(len(new_seq)-k):  
        # sliding window of k-mer bp over our 50bp
        k_motif = new_seq[i:i+k]        
        if !(k_motif in poss_motif): # if it isn't in the list then add it, and add a new item to score as well
          poss_motif.append(create_possible_motif(k_motif,k))  # k-motif is already length k 
          new_ic = pfm_ic(build_pfm(poss_motif,k))  # calculating pfm of multiple motifs, not using k-score
          poss_motif_score.append(new_ic)
        else:
          new_ic=pfm_ic(build_pfm(poss_motif,k)) # calc the new possible IC
        #  temp_index = poss_motif.index(k_motif) # look up the motif in the big list
        #  poss_motif_score[temp_index] = new_ic  #scores of motifs will match DNA(i) list/array
        
       # select position m from PWM-scored k-mers in DNAi in probabilistic fashion from score distribution
      rand_index = choose_motif(poss_motif, poss_motif_score) # probabilistic motif selection
      
      pfm = build_pfm(poss_motif[rand_index],k)
      
      current_ic = pfm_ic(pfm)
            
      # now check to see if the current_IC matches the one we did last time through the loop
      if not (fuzzy_diff (current_ic,poss_motif_score[N],0.000001)):
        # if they don't match, then re-set and start again with another motif
        poss_motif_score[N] = current_ic  ## poss_motif_score includes the bg scores and N is a random number we generated to remove from the poss_motif list 
        counter_ic = 0
      else:
        # if they do match, then we have converged
        return(np.array(pfm))
                
      counter_ic+=1
      j+=1
     
      #end of while loop; if we have reached here, there was no convergence return the last motif checked
    return (np.array(pfm))

```

```{python}
def convert_exp( poss_scores ):
  ''' function convert_exp()
    Converts a list of kmer scores into normalized values, and returns a list of normalzed floats, normalization is 2^(value)/sum(all values in pos & neg list)
    
    Args:
      poss_scores:  list of floats-contains kmer scores for motifs on DNAi strand
    
    Output:
      returns a list of nornmalized floats
  '''
  
  sum_all = abs(sum(poss_scores))
      
  exp_total = [math.exp2(score)/sum_all for score in poss_scores]
  
  return(exp_total)

```


```{python V3}
def GibbsMotifFinder (seqs, k, seed=42):
    """
    Function to find a pfm from a list of strings using a Gibbs sampler
  
    Args: 
      seqs (str list): a list of sequences, not necessarily in same lengths
      k (int): the length of motif to find
      seed (int, default=42): seed for np.random
    
    Returns:
      pfm (numpy array): dimensions are 4xlength
      
    """
    
    len_master = len(seqs)
    master_seq = [] # seqs + rev(seqs) twice as long
    all_motifs = []  # k-length of each possible motif
    background = []  # will be length(seq)-1
 
    pfm = []
    old_ic = 0
    
    master_seq = seqs
    
    for seq in master_seq:
      all_motifs.append(create_possible_motif(seq,k))
    ## poss_motif should be used for calculating the PWM --> I don't think a score is needed for each possible motif

    j = counter_ic = 0  # Set counter for j and IC
        
    while ((j < 10000) and (counter_ic < 100)): 
          
      N = random.randint(0, len_master-1)  # generate random number for selecting motif/sequence
          
      new_seq = master_seq[N]  # store full length sequence to loop through and calculate k-scores and ICs
          
      background = all_motifs[:N] + all_motifs[N+1:]  # all Motifs except Motifi
  
      bgPWM = build_pwm(build_pfm(background,k))  # PWM constructed from all Motifs except for Motifi
          
      poss_motifs = []  # list of possible motifs within the new_seq
      poss_motif_scores = []  # list of scores for each possible motifs in new_seq
      # NOTE:  DNAi arrays are local arrays only, they need to be reset each time you go through the big loop
      for i in range(len(new_seq)-k):  
        # sliding window of k-mer bp over our 50bp
        k_motif = new_seq[i:i+k]      
            
        ## if statement not needed, bc as it slides over it should not be the same unless it is all k bases are the same 
         # if !(k_motif in poss_motif): # if it isn't in the list then add it, and add a new item to score as well
        poss_motifs.append(k_motif) 
        new_kmer = score_kmer(k_motif, bgPWM)
        poss_motif_scores.append(new_kmer)  
            
      # poss_motif_scores would include negative values, therefore, we need to handle it for probablistic motif selection. We can convert log-odds to probabilities using exp
      exp_scores = convert_exp(poss_motif_scores) 
      
      rand_index = choose_motif(poss_motifs, exp_scores) # probabilistic motif selection
      
      all_motifs[N] = poss_motifs[rand_index]
      
      motif = []
      motif.append(poss_motifs[rand_index])
      pfm = build_pfm(motif, k)  # build pfm from the probabilistic selected motif
            
      current_ic = pfm_ic(pfm)
            
      if (fuzzy_diff (current_ic,old_ic,0.000001)):  #if the difference is minimal, add 1 to counter
        counter_ic += 1
      else:
        counter_ic = 0
    #  print(f"J: {j}, {motif}, PFM:{pfm} , Old IC: {old_ic}, Current IC: {current_ic}, IC Counter: {counter_ic}")
      
      old_ic = current_ic          
      j+=1
      
    #end of while loop; if we have reached here, there was no convergence return the last motif checked
    print("Final PFM:",pfm)
    return (np.array(pfm))
              
#Testing code
# seqs = [ "ATTCGACACACAGGGAAATTT", "GCGCTGCAGCCCGGGGTTTAAA", "ACACACACTTTTGGGGGG"]
#promoter_pfm = GibbsMotifFinder(seqs,10)
```


```{python Driver}
# Here we test your Gibbs sampler.
# You do not need to edit this or the section below. This is the Driver program

#read promoters, store in a list of strings
seq_file="data/GCF_000009045.1_ASM904v1_genomic.fna"
gff_file="data/GCF_000009045.1_ASM904v1_genomic.gff"

seqs = []

for name, seq in get_fasta(seq_file): # For each entry in our FASTA file
    for gff_entry in get_gff(gff_file): # For each entry in our GFF file
        if gff_entry.type == 'CDS': # If this is a coding sequence
            promoter_seq = get_seq(seq, gff_entry.start, gff_entry.end, gff_entry.strand, 50) # Extract 50 bp as a promoter             #'''
            #Because the gibbs sampling assumption is broken in just using promoters,
            #and because it takes very long time to randomly progress through so many
            #regions, for this example we will pre-filter for sequences that all contain
            #part of the shine-dalgarno motif:
            #'''
            if "AGGAGG" in promoter_seq:
                seqs.append(promoter_seq)
                seqs.append(reverse_complement(promoter_seq)) 
```


```{python}
# Run the gibbs sampler:

promoter_pfm = GibbsMotifFinder(seqs,10)

# Plot the final pfm that is generated: 
seqlogo.seqlogo(
    seqlogo.CompletePm(pfm = promoter_pfm.T), 
    format='png' , 
    filename = './stuff/motif.png'
)
```
Let's see the output now. You can either directly open the image or type in the
filename below. This image would also be included if you were to `knit` this document.

![](stuff/motif.png)




