---
title: "Project 03"
author: "Zoe Chow, Jacqueline Caldwell"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
```

---

# Gibbs sampling

---
## Imports

For this project, it tasks you with creating a sequence logo to plot the motif sequences identified through your algorithm.
This is a very minor portion of the project and is best used for checking your work. That means that if you cannot get the library
that you are about to install to work, don't worry. At a bare minimum, you only need `numpy` to complete this project.

```{r, install_seqlogo}
#reticulate::conda_install(packages=c('pdf2svg',"seqlogo"), forge=TRUE, channel="bioconda",conda="auto", additional_install_args="--solver=libmamba")
#reticulate::conda_install(packages=c("numpy","seqlogo"), forge=TRUE, channel="bioconda",conda="auto", additional_install_args="--solver=libmamba")
```


```{python}
import numpy as np
import seqlogo

#import function for building sequence motif & idenfitying seqs matching to motif
from data_readers import *
from seq_ops import get_seq
from motif_ops import *
```

---
## Implement Gibbs Sampler


Gibbs sampling is a MCMC approach to identify enrichments. Here we will implement a method to identify motifs from a set of regions. 

Important considerations:
- We will need to score each sequence with a PWM using the `score_kmer()` or `score_sequence()` functions
    - You will need to investigate into the help documenation and libraries to identify how best to use these functions. 
- These sites are often not strand-specific and so both scores on the negative as well as positive strand should be considered
- To select a random sequence, use `random.randint()` or `numpy.random.randint()`
- To select a new position $m$ (as defined below) use `random.choices()` or `numpy.random.choice()`  

Assumptions: 
- We know $k$ as the length of expected motif
- Each sequence contains the motif


Probability of chosing position $m = \frac{A_{m}}{\sum_{l}A_{l}}$ for positions $l$ in DNAi


**Note:** I have also added a function to `motif_ops.py` that will calculate the information content of your motifs. This is useful to observe the progression of your Gibbs sampler as well as a measure of convergence. You can use this function as `IC = pfm_ic(pfm)`. You should expect a slow increase of IC until it plateaus such as in the plot below from your lecture slides:   ![]('figures/Gibbs_Sampling.png')


```
GibbsMotifFinder(DNA, k-length)
    random pick of k-length sequences from each line of DNA as Motifs
    for j ← 1 to 10000 or Motifs stops changing
        i ← Random(N) where N is number of DNA entries
        PWM ← PWM constructed from all Motifs except for Motifi
        Motifi ← select position m from PWM-scored k-mers in DNAi in probabilistic fashion from score distribution
    return PFM

First draft of discussions:
GibbsMotifFinder(DNA, k-length) DNA - list of strings?, k-length = 10 initially
1. random pick of k-length seq from each line of DNA(seq) as motifs.
    from list of sequences --> pick a motif from each of them. will create (list pos_motif[250])

    2. for j  1 to 10000 or motifs stop changing (IC doesn't change or j==10000)
      3. i comes from Random(N) where N is number of DNA(seq) (250 - pick a # motif index)
        motif= DNA[i]
      4. PWM constructed from all other 249 promoters (Background???). PWM(PFM("DNA-motif sequence")) 4 x 249 matrix => matrix 4xk-mer long.
      5. Create the second for loop within 5; sliding window of k-mer bp over our 50bp
          recalculate for each - k-mer scores length of matrix (matrix 4 x k-mer)
          (saved k-mer with the highest score).
      6.
      recalculate PFM (4 x 10 matrix)
      7. calculate IC of PFM ()
      stop loop (2) if IC is the same x 100 or we've gotten to loop 10000

Second draft of discussions/pseudocode:
GibbsMotifFinder(DNA, k-length) DNA - list of strings?, k-length = 10 initially

Seqs[]=DNA[]
background set of strings k-length -1 
poss_motif[]
N – random index into motif/DNA

create list of poss_motifs (based on seqs) (one random from each seqs[])
     splitter to create motifs
    
j=counter_ic=0
     
loop (j==10000 or counter_ic == 100)
    N = randomly pick one poss_motif

    new_seq = seqs[N]

    create new_set of seqs that doesn’t contain the seqs[N] that the poss_motif[N] is associated with.
        background = seqs[-N]
           
    Calculate PWM(PFM(new_set))
     
    old k_mer = old_ic = 0

    Create the second for loop within 
     for in in length(new_seq-k)
       # sliding window of k-mer bp over our 50bp
           k_motif = new_seq[i:i+k]
           new_k-mer_score = score_k-mer(seq, PWM)
        
    	if (new_kmer > than old_kmer)
                old_kmer = new_kmer
                motif = kMotif
       pfm=build_pfm(motif)
       new_ic = pfm_ic(pfm)   (need to start the counter_ic = 0) 
 
       if (fuzzy_diff (new_ic,old_ic))
	update old_ic = new_ic
            counter_ic = 0
        else
             counter_ic+=1
        j+=1
   returning (pfm)
         
def fuzzy_diff(x,y)
{
  return(abs(x-y)) > 0.000001
}
```
```{python}
import numpy as np

#Support functions for GibbsMotifFinder()

def fuzzy_diff(x, y, epsilon):
     """
     Compares x and y within epsilon difference, and returns true or false
  
     Args:
     x,y (floats):  values to be compared, are they within epislon of each other if so 
        function returns TRUE, otherwise, returns FALSE
     epsilon (float) - the amount of difference, or tolerance between X & Y that we will allow
  
     Returns (boolean): if abs(x-y) os greater than epislon
     """
     
     if (abs(x-y) > epsilon):
          return(TRUE)
     else:
          return(FALSE)
  
  
def create_possible_motif(sequence, k=10):
     """
     Create a k-length motif from a larger sequence, using random selection
 
     Args:
     sequence (string):   single sequence to find a random motif in
     k (int):        length of proposed motif
    
     Returns:
     string of length k: containing motif 
     """
     
     high_val = len(sequence) - 10 # don't want to go beyond the end of the string
     print("ERR:  Need to fix the following line returning Syntax Indentation error here")
     N=0
#     N = np.random.random_integers(low=0, high=high_value, 1)
     return (sequence[N:N+10])

```


```{python}
def GibbsMotifFinder (seqs, k, seed=42):
     """
    Function to find a pfm from a list of strings using a Gibbs sampler
    
    Args: 
        seqs (str list): a list of sequences, not necessarily in same lengths
        k (int): the length of motif to find
        seed (int, default=42): seed for np.random

    Returns:
        pfm (numpy array): dimensions are 4xlength
        
    """
     len_seq = len(seq)
     background = [] # will be length(seq)-1
     poss_motif = [] 
 
     for seq in seqs:
          poss_motif.append(create_possible_motif(seq,k))
    
     j = counter_ic = 0
  
     while ((j != 10000) or (counter_ic != 100)):
          print("ERR: Need to fix the np.random... line below this in code, syntax error, commented out, remove N=0")
          N = 5
#          N = np.random.integers(0,len_seq,seed)
          new_seq = seqs[N]

# create new_set of seqs that doesn’t contain the seqs[N] that the poss_motif[N] is associated with.
    
          print("ERR: Need to fix seqs.pop, syntax error, N name not found",N)
#          background = seqs.pop(N)
           
          bgPWM = build_pwm(build_pfm(background,k))
     
          old_kmer = old_ic = 0
    
          list_of_motifs=[]
          scores_of_motifs=[]

    # Create the second for loop within 
          for i in (len(new_seq)-k):
      # sliding window of k-mer bp over our 50bp
               k_motif = new_seq[i:i+k]
               list_of_motifs.append(k_motif)
               new_kmer = score_kmer(k_motif, bgPWM)
               scores_of_motifs.append(new_kmer)  
    
          best_index = scores_of_motifs.index(max(scores_of_motifs))  
    
          motif = list_of_motifs[best_index]
    
          pfm = build_pfm(motif,k)
          new_ic = pfm_ic(pfm) 

          if (fuzzy_diff (new_ic,old_ic,0.000001)):
               old_ic = new_ic
               counter_ic = 0
          else:
               counter_ic+=1
    
          j+=1
  #end of while loop
  
     return (pfm)
```


```{python}
# Here we test your Gibbs sampler.
# You do not need to edit this or the section below. This is the Driver program

#read promoters, store in a list of strings
seq_file="data/GCF_000009045.1_ASM904v1_genomic.fna"
gff_file="data/GCF_000009045.1_ASM904v1_genomic.gff"

seqs = []

for name, seq in get_fasta(seq_file): # For each entry in our FASTA file
    for gff_entry in get_gff(gff_file): # For each entry in our GFF file
        if gff_entry.type == 'CDS': # If this is a coding sequence
            promoter_seq = get_seq(seq, gff_entry.start, gff_entry.end, gff_entry.strand, 50) # Extract 50 bp as a promoter             #'''
            #Because the gibbs sampling assumption is broken in just using promoters,
            #and because it takes very long time to randomly progress through so many
            #regions, for this example we will pre-filter for sequences that all contain
            #part of the shine-dalgarno motif:
            #'''
            if "AGGAGG" in promoter_seq:
                seqs.append(promoter_seq)
```


```{python}
# Run the gibbs sampler:
promoter_pfm = GibbsMotifFinder(seqs,10)

# Plot the final pfm that is generated: 
seqlogo.seqlogo(seqlogo.CompletePm(pfm = promoter_pfm.T))
```
